<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="MG8:LEu=T?|!G)|!!s-=" x="20" y="20"><statement name="HANDLER"><block type="typescript_statement" id="5/Nr4V(C7!C+Cz%}[,Z6"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace datetime {" line1="" line2="    export class dates { constructor(public month: number, public day: number, public year: number) { } }" line3="" line4="    //% blockId=datetime_dateshadow" line5="    //% block=&quot;month $month / day $day / year $year&quot; advanced=true" line6="    //% month.min=1 month.max=12 month.defl=1" line7="    //% day.min=1 day.max=31 day.defl=20" line8="    //% year.min=2020 year.max=2050 year.defl=2022" line9="    //% group=&quot;class one&quot;" line10="    //% weight=19" line11="    export function datev(month: number, day: number, year: number) { return new dates(((month-1)%12)+1, ((day-1)%31)+1, year) }" line12="" line13="    export class times { constructor(public hour: number, public minute: number, public second: number) { } }" line14="" line15="    //% blockId=datetime_timeshadow" line16="    //% block=&quot;$hour : $min . $sec&quot; advanced=true" line17="    //% hour.min=0 hour.max=23 hour.defl=13" line18="    //% min.min=0 min.max=59 min.defl=30" line19="    //% sec.min=0 sec.max=59 sec.defl=0" line20="    //% group=&quot;class one&quot;" line21="    //% weight=16" line22="    export function time24v(hour: number, min: number, sec: number) { return new times(hour % 24, min % 60, sec % 60) }" line23="" line24="    //% blockId=datetime_halftimeshadow" line25="    //% block=&quot;$hour : $min . $sec&quot; advanced=true" line26="    //% hour.min=1 hour.max=12 hour.defl=11" line27="    //% min.min=0 min.max=59 min.defl=30" line28="    //% sec.min=0 sec.max=59 sec.defl=0" line29="    //% group=&quot;class one&quot;" line30="    //% weight=13" line31="    export function time12v(hour: number, min: number, sec: number) { return new times(((hour + 11) % 12) + 1, min % 60, sec % 60) }" line32="" line33="    //% isInstance" line34="    export class dtobj {" line35="        public mydatetime: DateTime = { month: 1, day: 1, year: 1, hour: 0, minute: 0, second: 0, dayOfYear: 1, dayOfWeek: 0, daySince: 1}" line36="        public startYear: Year = 1; public cpuTimeAtSetpoint: SecondsCount = 0; public timeToSetpoint: SecondsCount = 0;" line37="        public inProcess: {[id: string]: boolean} = {}; public lastUpdate: DateTime = {month: NaN, day: NaN, year: NaN, hour: NaN, minute: NaN, second: NaN, dayOfYear: NaN, dayOfWeek: NaN, daySince: NaN}" line38="        " line39="        public run() {" line40="            /* " line41="            this ensures that &quot;time&quot; is checked periodically and event handlers are called.  " line42="            */" line43="            game.onUpdateInterval(1000, function () {" line44="                // Only run about every 2 s;  Micro:bit uses a ticker with a 32kHz period, so the count should increase by every 1s with about 65kHz for arcade or etc." line45="                const cpuTime = cpuTimeInSeconds(), t = timeFor(this, cpuTime)" line46="                this.mydatetime = t" line47="            })" line48="        }" line49="" line50="        constructor() { this.run() }" line51="    }" line52="" line53="    // ********* Enumerations for parameter types ************************" line54="" line55="    let monthName: string[][] = [" line56="        [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;]," line57="        [&quot;January&quot;, &quot;Febuary&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;Orgust&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;]" line58="    ]" line59="" line60="    let weekName: string[][] = [" line61="        [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;]," line62="        [&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;]" line63="    ]" line64="" line65="    export enum ValueUpdate {" line66="        //% block=&quot;Second&quot;" line67="        Second = 0," line68="        //% block=&quot;Minute&quot;" line69="        Minute = 1," line70="        //% block=&quot;Hour&quot;" line71="        Hour = 2," line72="        //% block=&quot;Day&quot;" line73="        Day = 3," line74="        //% block=&quot;Month&quot;" line75="        Month = 4," line76="        //% block=&quot;Year&quot;" line77="        Year = 5," line78="    }" line79="" line80="    export enum DropDatetime {" line81="        //% block=&quot;month&quot;" line82="        Month = 0," line83="        //% block=&quot;day of month&quot;" line84="        DayOfMonth = 1," line85="        //% block=&quot;year&quot;" line86="        Year = 2," line87="        //% block=&quot;hour&quot;" line88="        Hour = 3," line89="        //% block=&quot;minute&quot;" line90="        Minute = 4," line91="        //% block=&quot;second&quot;" line92="        Second = 5," line93="        //% block=&quot;day of year&quot;" line94="        DayOfYear = 6," line95="        //% block=&quot;day of week&quot;" line96="        DayOfWeek = 7," line97="        //% block=&quot;day since&quot;" line98="        DaySince = 8" line99="    }" line100="" line101="    export enum OffsetWeek {" line102="        //% block=&quot;sunday&quot;" line103="        SUN = 6," line104="        //% block=&quot;saturday&quot;" line105="        SAT = 5," line106="        //% block=&quot;monday&quot;" line107="        MON = 0" line108="    }" line109="" line110="    export enum MornNight {" line111="        //% block=&quot;am&quot;" line112="        AM," line113="        //% block=&quot;pm&quot;" line114="        PM" line115="    }" line116="" line117="    export enum TimeUnit {" line118="        //% block=&quot;ms&quot;" line119="        Milliseconds," line120="        //% block=&quot;seconds&quot;" line121="        Seconds," line122="        //% block=&quot;minutes&quot;" line123="        Minutes," line124="        //% block=&quot;hours&quot;" line125="        Hours," line126="        //% block=&quot;days&quot;" line127="        Days" line128="    }" line129="" line130="    export enum TimeFormat {" line131="        //% block=&quot;h:mm.ss am / pm&quot;" line132="        HMMSSAMPM," line133="        //% block=&quot;hh:mm 24-hr&quot;" line134="        HHMM24hr," line135="        //% block=&quot;hh:mm.ss 24-hr&quot;" line136="        HHMMSS24hr," line137="        //% block=&quot;h:mm&quot;" line138="        HMM," line139="        //% block=&quot;h:mm am / pm&quot;" line140="        HMMAMPM," line141="    }" line142="" line143="    export enum DateFormat {" line144="        //% block=day/subweekname/submonthname&quot;" line145="        DWnsMns," line146="        //% block=&quot;day/weekname/monthname&quot;" line147="        DWnMn," line148="        //% block=&quot;month/day&quot;" line149="        MD," line150="        //% block=&quot;month/day/year&quot;" line151="        MDY," line152="        //% block=&quot;year-month-day&quot;" line153="        YYYY_MM_DD" line154="    }" line155="" line156="    export enum MonthNameFormat {" line157="        //% block=&quot;Fullname&quot;" line158="        Fname," line159="        //% block=&quot;Subname&quot;" line160="        Sname," line161="    }" line162="" line163="    export enum WeekNameFormat {" line164="        //% block=&quot;Fullname&quot;" line165="        Fname," line166="        //% block=&quot;3Subname&quot;" line167="        S3name," line168="        //% block=&quot;2Subname&quot;" line169="        S2name," line170="    }" line171="" line172="    type Month = uint8   // 1-12 Month of year" line173="    type Day = uint8     // 1-31 / Day of month" line174="    type Year = uint16 // Assumed to be 0000-0099 or 2020-2099  " line175="    type Hour = uint8  // 0-23 / 24-hour format  " line176="    type Minute = uint8 // 0-59 " line177="    type Second = uint8 // 0-59" line178="    type DayOfYear = uint16 // 1-366" line179="" line180="    type SecondsCount = uint32 // Seconds since start of start year" line181="    type Weekday = uint8 // Weekday code. 0=Sunday, 1=Monday, etc." line182="    type Weekyear = uint8 // 0-51 (1-52) / Weekyear format" line183="" line184="    interface DateTime {" line185="        month: Month   // 1-12 Month of year" line186="        day: Day   // 1-31 / Day of month" line187="        year: Year  // Assumed to be 2020 or later" line188="        hour: Hour   // 0-23 / 24-hour format  " line189="        minute: Minute   // 0-59 " line190="        second: Second   // 0-59" line191="        dayOfYear: DayOfYear  // 1-366" line192="        dayOfWeek: Weekday // 0-6 / weekday value" line193="        daySince: SecondsCount // Day of since" line194="    }" line195="" line196="    interface Date {" line197="        month: Month   // 1-12 Month of year" line198="        day: Day   // 1-31 / Day of month" line199="        year: Year  // Assumed to be 2020 or later" line200="        dayOfYear: DayOfYear  // 1-366" line201="        dayOfWeek: Weekday // 0-6 / weekday value" line202="        daySince: SecondsCount // Day of since" line203="    }" line204="" line205="    interface MonthDay {" line206="        month: Month   // 1-12 Month of year" line207="        day: Day   // 1-31 / Day of month" line208="    }" line209="" line210="    // ********* State Variables ************************" line211="" line212="    const TIME_AND_DATE_EVENT = 94" line213="    const TIME_AND_DATE_NEWMINUTE = 1" line214="    const TIME_AND_DATE_NEWHOUR = 2" line215="    const TIME_AND_DATE_NEWDAY = 3" line216="" line217="    // State variables to manage time " line218="    let startYear: Year = 0" line219="    let timeToSetpoint: SecondsCount = 0" line220="    let cpuTimeAtSetpoint: SecondsCount = 0" line221="" line222="    /*    " line223="    Time is all relative to the &quot;start year&quot; that is set by setDate() (or 0 by default) as follows:" line224="" line225="      Start year          Time Date/Time set        CurrentCPUTime" line226="      |                   | (in s)                  | (in s)" line227="      V                   V                         V" line228="      |-------------------+-------------------------|" line229="                          ^" line230="                          |" line231="                          Known dd/mm/yy hh:mm,.s" line232="                          AND cpuTimeAtSetpoint (in s)" line233="       |------------------|-------------------------|" line234="          timeToSetpoint          deltaTime" line235="          (in s)                  ( in s)" line236="    " line237="        setDate sets the startYear and updates timeToSetpoint and cpuTimeAtSetpoint " line238="        setTime methods update just timeToSetpoint and cpuTimeAtSetpoint" line239="     */" line240="" line241="    // State for event handlers " line242="    let lastUpdateMinute: Minute = 100   // Set to invalid values for first update" line243="    let lastUpdateHour: Hour = 100" line244="    let lastUpdateDay: Day = 100" line245="" line246="" line247="    // Cummulative Days of Year (cdoy): Table of month (1-based indices) to cummulative completed days prior to month" line248="    // Ex: By Feb 1st (2nd month / index 2), 31 days of Jan are completed. " line249="    const cdoy: DayOfYear[] = [0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]" line250="" line251="    // ********* Time Calculation / Management ************************" line252="" line253="" line254="    function isLeapYear(y: Year): boolean {" line255="        // The /400 and /100 rules don't come into play until 2400 and 2300 or 0100.  We can ignore them here" line256="        // Here's the code for accurate handling of leap years:" line257="        return (y % 400 == 0 || (y % 100 != 0 &amp;&amp; y % 4 == 0))" line258="" line259="        // Simplified case for 2020-2099." line260="        // return y % 4 == 0" line261="    }" line262="" line263="" line264="    // Returns a MonthDay with from a DayOfYear and given Year" line265="    function dayOfYearToMonthAndDay(d: DayOfYear, y: Year): MonthDay {" line266="        // If it's after Feb in a leap year, adjust" line267="        if (isLeapYear(y)) {" line268="            if (d == 60) {  // Leap Day!" line269="                return { month: 2, day: 29 }" line270="            } else if (d &gt; 60) {" line271="                d -= 1  // Adjust for leap day" line272="            }" line273="        }" line274="        for (let i = 1; i &lt; cdoy.length; i++) {  // Start at 1 for 1- based index" line275="            // If the day lands in (not through) mydt month, return it" line276="            if (d &lt;= cdoy[i + 1]) {" line277="                return { month: i, day: d - cdoy[i] }" line278="            }" line279="        }" line280="        // mydt should never happen!" line281="        return { month: -1, day: -1 }" line282="    }" line283="" line284="    function secondsSoFarForYear(m: Month, d: Day, y: Year, hh: Hour, mm: Minute, ss: Second): SecondsCount {" line285="        // ((((Complete Days * 24hrs/ day)+complete hours)*60min/ hr)+complete minutes)* 60s/ min + complete seconds" line286="        // Yay Horner's Rule!:" line287="        return (((dateToDayOfYear(datev(m, d, y)) - 1) * 24 + hh) * 60 + mm) * 60 + ss" line288="    }" line289="" line290="    function dateSinceFor(dateSince: SecondsCount, offsetSince: SecondsCount = 0, offsetYear: Year = 0): Date {" line291="        // Find elapsed years by counting up from start year and subtracting off complete years" line292="        let startDateCount = dateSince" line293="        if (offsetSince &gt; 0 &amp;&amp; dateSince &gt; offsetSince) startDateCount -= offsetSince" line294="        let y = 1" line295="        if (offsetYear &gt; 0) y = offsetYear" line296="        let leap = isLeapYear(y)" line297="        while ((!leap &amp;&amp; startDateCount &gt; 365) || (startDateCount &gt; 366)) {" line298="            if (leap) {" line299="                startDateCount -= 366" line300="            } else {" line301="                startDateCount -= 365" line302="            }" line303="            y += 1" line304="            leap = isLeapYear(y)" line305="        }" line306="" line307="        // sSinceStartOfYear and leap are now for &quot;y&quot;, not &quot;year&quot;.  Don't use &quot;year&quot;! Use &quot;y&quot;" line308="        // Find elapsed days" line309="        const daysFromStartOfYear = Math.constrain(startDateCount, 1, (isLeapYear(y)) ? 366 : 365) // +1 offset for 1/1 being day " line310="" line311="        // Convert days to dd/ mm" line312="        const ddmm = dayOfYearToMonthAndDay(daysFromStartOfYear, y) // current year, y, not start year" line313="" line314="        const weekv = dateToDayOfWeek(datev(ddmm.month, ddmm.day, y))" line315="        const daysincev = dateToDaySince(datev(ddmm.month, ddmm.day, y))" line316="" line317="        return { month: ddmm.month, day: ddmm.day, year: y, dayOfYear: daysFromStartOfYear , dayOfWeek: weekv, daySince: daysincev}" line318="    }" line319="" line320="    function timeFor(mydt: dtobj, cpuTime: SecondsCount): DateTime {" line321="        const deltaTime = cpuTime - mydt.cpuTimeAtSetpoint" line322="        let sSinceStartOfYear = mydt.timeToSetpoint + deltaTime, uSince = sSinceStartOfYear" line323="        // Find elapsed years by counting up from start year and subtracting off complete years" line324="        let y2 = mydt.startYear" line325="        let leap2 = isLeapYear(y2)" line326="        while ((!leap2 &amp;&amp; sSinceStartOfYear &gt; 365 * 24 * 60 * 60) || (sSinceStartOfYear &gt; 366 * 24 * 60 * 60)) {" line327="            if (leap2) {" line328="                sSinceStartOfYear -= 366 * 24 * 60 * 60" line329="            } else {" line330="                sSinceStartOfYear -= 365 * 24 * 60 * 60" line331="            }" line332="            y2 += 1" line333="            leap2 = isLeapYear(y2)" line334="        }" line335="" line336="        // sSinceStartOfYear and leap are now for &quot;y&quot;, not &quot;year&quot;.  Don't use &quot;year&quot;! Use &quot;y&quot;" line337="        // Find elapsed days" line338="        const daysFromStartOfYear2 = Math.constrain(Math.floor(sSinceStartOfYear / (24 * 60 * 60))+1, 1, (isLeapYear(y2)) ? 366 : 365)  // +1 offset for 1/1 being day 1 and maximum for 366 if is LeapYear or 365 if not LeapYear" line339="        const secondsSinceStartOfDay = sSinceStartOfYear % (24 * 60 * 60)" line340="" line341="        // Find elapsed hours" line342="        const hoursFromStartOfDay = Math.floor(secondsSinceStartOfDay / (60 * 60))" line343="        const secondsSinceStartOfHour = secondsSinceStartOfDay % (60 * 60)" line344="" line345="        // Find elapsed minutes" line346="        const minutesFromStartOfHour = Math.floor(secondsSinceStartOfHour / (60))" line347="        // Find elapsed seconds" line348="        const secondsSinceStartOfMinute = secondsSinceStartOfHour % (60)" line349="" line350="        // Convert days to dd/ mm" line351="        const ddmm2 = dayOfYearToMonthAndDay(daysFromStartOfYear2, y2) // current year, y, not start year" line352="" line353="        const weekv2 = dateToDayOfWeek(datev(ddmm2.month, ddmm2.day, y2))" line354="        const daysincev2 = dateToDaySince(datev(ddmm2.month, ddmm2.day, y2))" line355="" line356="        mydt.mydatetime = { month: ddmm2.month, day: ddmm2.day, year: y2, hour: hoursFromStartOfDay, minute: minutesFromStartOfHour, second: secondsSinceStartOfMinute, dayOfYear: daysFromStartOfYear2, dayOfWeek: weekv2, daySince: daysincev2 }" line357="        return mydt.mydatetime" line358="    }" line359="" line360="    function timeSinceFor(timeSince: SecondsCount, offsetSince: SecondsCount = 0, offsetYear: Year = 0): DateTime {" line361="        let sSinceStartOfYear2 = timeSince" line362="        if (offsetSince &gt; 0 &amp;&amp; timeSince &gt; offsetSince) sSinceStartOfYear2 -= offsetSince" line363="        // Find elapsed years by counting up from start year and subtracting off complete years" line364="        let y3 = 1" line365="        if (offsetYear &gt; 0) y3 = offsetYear" line366="        let leap3 = isLeapYear(y3)" line367="        while ((!leap3 &amp;&amp; sSinceStartOfYear2 &gt; 365 * 24 * 60 * 60) || (sSinceStartOfYear2 &gt; 366 * 24 * 60 * 60)) {" line368="            if (leap3) {" line369="                sSinceStartOfYear2 -= 366 * 24 * 60 * 60" line370="            } else {" line371="                sSinceStartOfYear2 -= 365 * 24 * 60 * 60" line372="            }" line373="            y3 += 1" line374="            leap3 = isLeapYear(y3)" line375="        }" line376="" line377="        // sSinceStartOfYear and leap are now for &quot;y&quot;, not &quot;year&quot;.  Don't use &quot;year&quot;! Use &quot;y&quot;" line378="        // Find elapsed days" line379="        const daysFromStartOfYear3 = Math.constrain(Math.floor(sSinceStartOfYear2 / (24 * 60 * 60)) + 1, 1, isLeapYear(y3) ? 366 : 365) // +1 offset for 1/1 being day 1" line380="        const secondsSinceStartOfDay2 = sSinceStartOfYear2 % (24 * 60 * 60)" line381="" line382="        // Find elapsed hours" line383="        const hoursFromStartOfDay2 = Math.floor(secondsSinceStartOfDay2 / (60 * 60))" line384="        const secondsSinceStartOfHour2 = secondsSinceStartOfDay2 % (60 * 60)" line385="" line386="        // Find elapsed minutes" line387="        const minutesFromStartOfHour2 = Math.floor(secondsSinceStartOfHour2 / (60))" line388="        // Find elapsed seconds" line389="        const secondsSinceStartOfMinute2 = secondsSinceStartOfHour2 % (60)" line390="" line391="        // Convert days to dd/ mm" line392="        const ddmm3 = dayOfYearToMonthAndDay(daysFromStartOfYear3, y3) // current year, y, not start year" line393="" line394="        const weekv3 = dateToDayOfWeek(datev(ddmm3.month, ddmm3.day, y3))" line395="        const daysincev3 = dateToDaySince(datev(ddmm3.month, ddmm3.day, y3))" line396="" line397="        return { month: ddmm3.month, day: ddmm3.day, year: y3, hour: hoursFromStartOfDay2, minute: minutesFromStartOfHour2, second: secondsSinceStartOfMinute2, dayOfYear: daysFromStartOfYear3, dayOfWeek: weekv3, daySince: daysincev3 }" line398="    }" line399="" line400="    //% shim=DateTime::cpuTimeInSeconds" line401="    function cpuTimeInSeconds(): uint32 {" line402="        return Math.floor(game.runtime() / 1000)" line403="    }" line404="" line405="    // ********* Misc. Utility Functions for formatting ************************" line406="    function leftZeroPadTo(inp: number, digits: number) {" line407="        let value = inp + &quot;&quot;" line408="        while (value.length &lt; digits) {" line409="            value = &quot;0&quot; + value" line410="        }" line411="        return value" line412="    }" line413="" line414="" line415="    // 24-hour time:  hh:mm.ss" line416="    function fullTime(t: DateTime): string {" line417="        return leftZeroPadTo(t.hour, 2) + &quot;:&quot; + leftZeroPadTo(t.minute, 2) + &quot;.&quot; + leftZeroPadTo(t.second, 2)" line418="    }" line419="" line420="    // Full year: yyyy-mm-dd" line421="    function fullYear(t: DateTime, yf: boolean = false): string {" line422="        const yv = (yf)?543:0" line423="        return leftZeroPadTo(t.year + yv, 4) + &quot;-&quot; + leftZeroPadTo(t.month, 2) + &quot;-&quot; + leftZeroPadTo(t.day, 2)" line424="    }" line425="" line426="" line427="    // ********* Exposed blocks ************************" line428="" line429="    /**" line430="     * get create a new datetime" line431="     */" line432="    //% blockId=datetime_newdatetime" line433="    //% block=&quot;create new datetime&quot;" line434="    //% inlineInputMode=inline" line435="    //% blockSetVariable=&quot;myDateTime&quot;" line436="    //% shim=DateTime::newDatetime" line437="    //% group=&quot;create datetime&quot;" line438="    //% weight=140" line439="    export function newDatetime() { return new dtobj() }" line440="" line441="    //% blockId=datetime_mydt_getdateclass" line442="    //% block=&quot;get $mydt as date class month/day/year&quot; advanced=true" line443="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line444="    //% shim=DateTime::mydtAsDateC" line445="    //% group=&quot;class one&quot;" line446="    //% weight=9" line447="    export function mydtAsDateC(mydt: dtobj) { return new dates(((mydt.mydatetime.month-1)%12)+1, ((mydt.mydatetime.day-1)%31)+1, mydt.mydatetime.year)}" line448="" line449="    //% blockId=datetime_mydt_gettime24class" line450="    //% block=&quot;get $mydt as 24time class hour/minute/second&quot; advanced=true" line451="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line452="    //% shim=DateTime::mydtAsT24c" line453="    //% group=&quot;class one&quot;" line454="    //% weight=6" line455="    export function mydtAsT24c(mydt: dtobj) { return new times(mydt.mydatetime.hour % 24, mydt.mydatetime.minute % 60, mydt.mydatetime.second % 60)}" line456="" line457="    //% blockId=datetime_mydt_gettime24class" line458="    //% block=&quot;get $mydt as 12time class hour/minute/second&quot; advanced=true" line459="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line460="    //% shim=DateTime::mydtAsT12c" line461="    //% group=&quot;class one&quot;" line462="    //% weight=3" line463="    export function mydtAsT12c(mydt: dtobj) { return new times(((mydt.mydatetime.hour+11)%12)+1, mydt.mydatetime.minute % 60, mydt.mydatetime.second % 60)}" line464="" line465="    /**" line466="     * get the datetime value from kind data" line467="     * @param dropdown of datetime list" line468="     * @param datetime kind to get" line469="     */" line470="    //% blockId=datetime_getvaluefromkinddata" line471="    //% block=&quot; $mydt get datetime value as $dt&quot;" line472="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line473="    //% inlineInputMode=inline" line474="    //% shim=DateTime::getDataFromDtObj" line475="    //% group=&quot;number of datetime&quot;" line476="    //% weight=133" line477="    export function getDataFromDtObj(mydt: dtobj, dt: DropDatetime) {" line478="        const udatetime = mydt.mydatetime" line479="        switch (dt) {" line480="            case 0: return udatetime.month; break;" line481="            case 1: return udatetime.day; break;" line482="            case 2: return udatetime.year; break;" line483="            case 3: return udatetime.hour; break;" line484="            case 4: return udatetime.minute; break;" line485="            case 5: return udatetime.second; break;" line486="            case 6: return udatetime.dayOfYear; break;" line487="            case 7: return udatetime.dayOfWeek; break;" line488="            case 8: return udatetime.daySince; break;" line489="        }" line490="        return -1" line491="    }" line492="" line493="    /**" line494="     * Set the time using 24-hour format. " line495="     * @param mydt is the datetime object as mydatetime" line496="     * @param time from hour the hour (0-23), minute the minute (0-59), @param second the second (0-59)" line497="     */" line498="    //% blockid=datetime_set24hrtime" line499="    //% block=&quot; $mydt set time from 24-hour time $times&quot;" line500="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line501="    //% times.shadow=datetime_timeshadow" line502="    //% group=&quot;time setting&quot;" line503="    //% weight=90" line504="    export function set24HourTime(mydt: dtobj, times: times) {" line505="        let hour = times.hour, minute = times.minute, second = times.second" line506="        hour = hour % 24" line507="        minute = minute % 60" line508="        second = second % 60" line509="        const cpuTime2 = cpuTimeInSeconds()" line510="        const u = timeFor(mydt, cpuTime2)" line511="        mydt.cpuTimeAtSetpoint = cpuTime2" line512="        mydt.timeToSetpoint = secondsSoFarForYear(u.month, u.day, u.year, hour, minute, second)" line513="    }" line514="" line515="    /**" line516="     * Set the date" line517="     * @param mydt is the datetime object as mydatetime" line518="     * @param date from month the month 1-12, day the day of the month 1-31, @param the year 2020-2050" line519="     */" line520="    //% blockid=datetime_setdate" line521="    //% block=&quot; $mydt set date to $dates&quot;" line522="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line523="    //% dates.shadow=datetime_dateshadow" line524="    //% group=&quot;date setting&quot;" line525="    //% weight=80" line526="    export function setDate(mydt: dtobj, dates: dates) {" line527="        let year = dates.year, month = dates.month, day = dates.day" line528="        month = ((month-1)%12)+1" line529="        day = ((day-1)%31)+1" line530="        const cpuTime3 = cpuTimeInSeconds()" line531="        const v = timeFor(mydt, cpuTime3)" line532="        mydt.startYear = year" line533="        mydt.cpuTimeAtSetpoint = cpuTime3" line534="        mydt.timeToSetpoint = secondsSoFarForYear(month, day, mydt.startYear, v.hour, v.minute, v.second)" line535="    }" line536="" line537="    /**" line538="     * Set the time using am/pm format" line539="     * @param mydt is the datetime object as mydatetime" line540="     * @param time from hour the hour (1-12), minute the minute (0-59), second the second (0-59)" line541="     * @param ampm morning or night" line542="     */" line543="    //% block=datetime_settime" line544="    //% block=&quot; $mydt set time to $times as $ampm&quot;" line545="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line546="    //% times.shadow=datetime_halftimeshadow" line547="    //% inlineInputMode=inline" line548="    //% group=&quot;time setting&quot;" line549="    //% weight=100" line550="    export function set12HourTime(mydt: dtobj, times: times, ampm: MornNight) {" line551="        let hour2 = times.hour, minute2 = times.minute, second2 = times.second" line552="        hour2 = (hour2 - 1 % 12) + 1" line553="        // Adjust to 24-hour time format" line554="        if (ampm == MornNight.AM &amp;&amp; hour2 == 12) {  // 12am -&gt; 0 hundred hours" line555="            hour2 = 0;" line556="        } else if (ampm == MornNight.PM &amp;&amp; hour2 != 12) {   // PMs other than 12 get shifted after 12:00 hours" line557="            hour2 + 12;" line558="        }" line559="        set24HourTime(mydt, time24v(hour2, minute2, second2));" line560="    }" line561="" line562="    /**" line563="     * Advance the time by the given amount, which cause &quot;carries&quot; into other aspects of time/date.  Negative values will cause time to go back by the amount." line564="     * @param mydt is the datetime object as mydatetime" line565="     * @param amount the amount of time to add (or subtract if negative).  To avoid &quot;carries&quot; use withTime blocks" line566="     * @param unit the unit of time" line567="     */" line568="    //% blockid=datetime_advancesetdatetime" line569="    //% block=&quot; $mydt advance time/date by $amount $unit&quot; advanced=true" line570="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line571="    //% group=&quot;advance setting&quot;" line572="    //% weight=50" line573="    export function advanceBy(mydt: dtobj, amount: number, unit: TimeUnit) {" line574="        const units = [0, 1, 60 * 1, 60 * 60 * 1, 24 * 60 * 60 * 1]" line575="        // Don't let time go negative:" line576="        if (amount &lt; 0 &amp;&amp; (-amount * units[unit]) &gt; mydt.timeToSetpoint)" line577="            mydt.timeToSetpoint = 0" line578="        else" line579="            mydt.timeToSetpoint += amount * units[unit]" line580="    }" line581="" line582="    /**" line583="     * Get day since from date" line584="     * @param date of month day year" line585="     */" line586="    //% blockid=datetime_datetodaysince" line587="    //% block=&quot;day since as $dates&quot; advanced=true" line588="    //% dates.shadow=datetime_dateshadow" line589="    //% group=&quot;calculate&quot;" line590="    //% weight=20" line591="    export function dateToDaySince(dates: dates): SecondsCount {" line592="        let uyear = dates.year, umonth = dates.month, uday = dates.day" line593="        umonth = Math.constrain(umonth, 1, 12)" line594="        let daySince = 0" line595="        for (let yidx = 1; yidx &lt; uyear; yidx++) daySince += (isLeapYear(yidx)) ? 366 : 365;" line596="        daySince += dateToDayOfYear(datev(umonth, uday, uyear))" line597="        return daySince" line598="    }" line599="" line600="    /**" line601="     * Get time since from date and time" line602="     * @param date of month day year" line603="     * @param time of hour minute second" line604="     */" line605="    //% blockid=datetime_datetodaysince" line606="    //% block=&quot;time since as $dates and $times&quot; advanced=true" line607="    //% dates.shadow=datetime_dateshadow" line608="    //% times.shadow=datetime_timeshadow" line609="    //% group=&quot;calculate&quot;" line610="    //% weight=20" line611="    export function dateAndTimeToTimeSince(dates: dates, times: times): SecondsCount {" line612="        let uyear2 = dates.year, umonth2 = dates.month, uday2 = dates.day" line613="        let uhour = times.hour, uminute = times.minute, usecond = times.second" line614="        umonth2 = Math.constrain(umonth2, 1, 12)" line615="        let timeSince = 0" line616="        for (let yidx2 = 1; yidx2 &lt; uyear2; yidx2++) timeSince += ((isLeapYear(yidx2)) ? 366 : 365) * (24 * 60 * 60);" line617="        timeSince += dateToDayOfYear(datev(umonth2, uday2, uyear2)) * (24 * 60 * 60)" line618="        timeSince += (uhour % 24) * (60 * 60), timeSince += (uminute % 60) * (60), timeSince += (usecond % 60)" line619="        return timeSince" line620="    }" line621="" line622="    /**" line623="     * Get the Day of the week  " line624="     * @param 0=&gt;Monday, 1=&gt;Tuesday, etc." line625="     */" line626="    //% blockid=datetime_date2dayweek" line627="    //% block=&quot;day of week for $datei&quot; advanced=true" line628="    //% datei.shadow=datetime_dateshadow" line629="    //% group=&quot;calculate&quot;" line630="    //% weight=40" line631="    export function dateToDayOfWeek(datei: dates): Weekday {" line632="        let yv2 = datei.year" line633="        let doy = dateToDayOfYear(datei)" line634="        // Gauss's Algorithm for Jan 1: https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week" line635="        // R(1+5R(A-1,4)+4R(A-1,100)+6R(A-1,400),7)    " line636="        let jan1 = ((1 + (5 * ((yv2 - 1) % 4)) + (4 * ((yv2 - 1) % 100)) + (6 * ((yv2 - 1) % 400))) % 7)" line637="        jan1 += 6  // Shift range:  Gauss used 0=Sunday, we'll use 0=Monday" line638="        return ((doy - 1) + jan1) % 7" line639="    }" line640="    " line641="    /**" line642="     * Get the Week of year" line643="     * @param weekofyear are minimum for 0 and maximum for 51" line644="     */" line645="    //% blockId=datetime_date2weekofyear" line646="    //% block=&quot;week of year for $datei&quot; advanced=true" line647="    //% datei.shadow=datetime_dateshadow" line648="    //% group=&quot;calculate&quot;" line649="    //% weight=35" line650="    export function dateToWeekOfYear(datei: dates): Weekyear {" line651="        let yv3 = datei.year" line652="        let doy2 = dateToDayOfYear(datei)" line653="        let jan12 = ((1 + (5 * ((yv3 - 1) % 4)) + (4 * ((yv3 - 1) % 100))) + ((6 * ((yv3 - 1) % 400))) % 7)" line654="        jan12 += 6" line655="        let dwoy = ((doy2 - 1) + jan12)" line656="        return Math.floor(dwoy / 7) % 52" line657="    }" line658="" line659="    /**" line660="     * Get the Day of the year  " line661="     * @param Jan 1 = 1, Jan 2=2, Dec 31 is 365 or 366" line662="     */" line663="    //% blockid=datetime_date2dayyear" line664="    //% block=&quot;day of year for $dates&quot; advanced=true" line665="    //% dates.shadow=datetime_dateshadow" line666="    //% group=&quot;calculate&quot;" line667="    //% weight=30" line668="    export function dateToDayOfYear(dates: dates): DayOfYear {" line669="        let year2 = dates.year, month2 = dates.month, day2 = dates.day" line670="        month2 = Math.constrain(month2, 1, 12)" line671="        // Assumes a valid date" line672="        let dayOfYear = cdoy[month2] + day2" line673="        // Handle after Feb in leap years:" line674="        if (month2 &gt; 2 &amp;&amp; isLeapYear(year2)) {" line675="            dayOfYear += 1" line676="        }" line677="        return dayOfYear" line678="    }" line679="" line680="    /**" line681="     * calculate my age from my birthdate in current date" line682="     * @param mydt the datetimeobject for current datetime" line683="     * @param idate the birthdate value" line684="     */" line685="    //% blockId=datetime_mydatetoage" line686="    //% block=&quot; $mydt get age from birthdate by $idate in current date&quot; advanced=true" line687="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line688="    //% idate.shadow=datetime_dateshadow" line689="    //% group=&quot;calculate&quot;" line690="    //% weight=14" line691="    export function myDateToAge(mydt: dtobj, idate: dates) {" line692="        let age = mydt.mydatetime.year - idate.year" line693="        if (mydt.mydatetime.month &lt; idate.month ||(mydt.mydatetime.month == idate.month &amp;&amp; mydt.mydatetime.day &lt; idate.day)) age--" line694="        return age" line695="    }" line696="" line697="    /**" line698="     * create calendar table from date" line699="     * @param idate the date to create raw calendar" line700="     * @param startweek the offset week for calendar" line701="     * @param max row grid" line702="     * @param camera calendar mode" line703="     */" line704="    //% blockid=datetime_datetable" line705="    //% block=&quot;raw calendar table as $idate in $startweek|| and max row $rowv and camera mode $cammode&quot; advanced=true" line706="    //% idate.shadow=datetime_dateshadow" line707="    //% rowv.min=1 rowv.max=3 rowv.defl=2" line708="    //% cammode.shadow=toggleYesNo" line709="    //% group=&quot;calculate&quot;" line710="    //% weight=15" line711="    export function dateAsTableList(idate: dates, startweek: OffsetWeek, rowv: number = 0, cammode: boolean = false): number[] {" line712="        let dateCountI = dateToDaySince(idate), dateI = dateSinceFor(dateCountI)" line713="        let dateWeek = dateToDayOfWeek(datev(dateI.month, dateI.day, dateI.year))" line714="        let camrow = (rowv &gt; 2 &amp;&amp; cammode)?Math.floor(rowv / 2):0" line715="        while ((cammode &amp;&amp; camrow &gt; 0)||(!cammode &amp;&amp;(rowv &gt; 0 &amp;&amp; dateWeek != startweek)||(rowv &lt;= 0 &amp;&amp;(dateI.month == idate.month || dateWeek != startweek)))) {" line716="            if (dateSinceFor(dateCountI - 1).month != idate.month &amp;&amp; dateWeek == startweek) break;" line717="            dateCountI--" line718="            if (dateCountI &lt; 0) return []" line719="            dateI = dateSinceFor(dateCountI)" line720="            dateWeek = dateToDayOfWeek(datev(dateI.month, dateI.day, dateI.year))" line721="            if (cammode&amp;&amp;(camrow &gt; 0 &amp;&amp; dateWeek == startweek)) camrow--" line722="        }" line723="        let tableDate: number[] = []" line724="        let tableCol = 7, tableRow = (rowv &gt; 0)?rowv:6" line725="        for (let tableidx = 0; tableidx &lt; tableCol * tableRow; tableidx++) {" line726="            dateI = dateSinceFor(dateCountI + tableidx)" line727="            tableDate.push((idate.month == dateI.month) ? dateI.day : -dateI.day)" line728="        }" line729="        return tableDate" line730="    }" line731="" line732="    /**" line733="     * create calendar table from date" line734="     * @param myDate the current date" line735="     * @param startweek the offset week for calendar" line736="     * @param max row grid" line737="     * @param camera calendar mode" line738="     * @param the forground color" line739="     * @param the background color" line740="     */" line741="    //% blockid=datetime_calendarimage" line742="    //% block=&quot;calendar as image $myDate in $startweek|| maxrow $rowv camera mode $cammode fgcolor $fgcol bgcolor $bgcol&quot;" line743="    //% myDate.shadow=variables_get myDate.defl=myDateTime" line744="    //% fgcol.shadow=colorindexpicker" line745="    //% bgcol.shadow=colorindexpicker" line746="    //% rowv.min=1 rowv.max=3 rowv.defl=2" line747="    //% cammode.shadow=toggleYesNo" line748="    //% group=&quot;image output&quot;" line749="    //% weight=15" line750="    export function calendarImage(myDate: dtobj, startweek: OffsetWeek, rowv: number = 0, cammode: boolean = false, fgcol: number = 1, bgcol: number = 15) {" line751="        if (myDate.inProcess[&quot;calendar&quot;]) return image.create(16, 16)" line752="        myDate.inProcess[&quot;calendar&quot;] = true" line753="        let calennum: number[] = dateAsTableList(datev(myDate.mydatetime.month, myDate.mydatetime.day, myDate.mydatetime.year), startweek, rowv, cammode)" line754="        if (calennum.length &lt;= 0){" line755="            myDate.inProcess[&quot;calendar&quot;] = false" line756="            return image.create(16, 16)" line757="        }" line758="        let calenstr: string[] = []" line759="        for (let j = 0;j &lt; 7;j++) {" line760="            calenstr.push(weekName[1][(j+startweek)%7].substr(0,2).toUpperCase())" line761="        }" line762="        for (let val of calennum) {" line763="            if (val &lt; 0) {" line764="                val = Math.abs(val)" line765="            }" line766="            calenstr.push(val.toString())" line767="        }" line768="        let twidth = 15, theight = 9, gtcol = 7, gtrow = (rowv &gt; 0)?rowv+1:7" line769="        let outputimg: Image = image.create((gtcol*twidth)+1, (gtrow*theight)+1)" line770="        outputimg.fill(bgcol)" line771="        outputimg.drawRect(0, 0, (gtcol * twidth) + 1, (gtrow * theight) + 1, fgcol)" line772="        for (let k = 1;k &lt; gtcol;k++) outputimg.fillRect((k * twidth), 0, 1, outputimg.height, fgcol)" line773="        for (let l = 1;l &lt; gtrow;l++) outputimg.fillRect(0, (l * theight), outputimg.width, 1, fgcol)" line774="        outputimg.fillRect(0, 0, (gtcol * twidth) + 1, theight + 1, fgcol)" line775="        outputimg.fillRect(0, theight - 1, (gtcol * twidth) + 1, 1, bgcol)" line776="        outputimg.drawRect(0, 0, (gtcol * twidth) + 1, (gtrow * theight) + 1, fgcol)" line777="        for (let m = 0;m &lt; calenstr.length;m++) {" line778="            const gcol = m % 7, grow = Math.floor(m / 7), txt = calenstr[m]" line779="            if (grow &gt; 0) {" line780="                const cnum = calennum[Math.max(0,m-7)]" line781="                outputimg.print(txt, 1+(gcol * twidth) + Math.floor((twidth / 2) - ((txt.length * 6) / 2)), 1 + (grow * theight) + Math.floor((theight / 2) - (8 / 2)), fgcol)" line782="                if (cnum &gt; 0) {" line783="                    if (myDate.mydatetime.day == cnum) {" line784="                        outputimg.fillRect(gcol * twidth, grow * theight, twidth + 1, theight + 1, fgcol)" line785="                        outputimg.print(txt, 1+(gcol * twidth) + Math.floor((twidth / 2) - ((txt.length * 6) / 2)), 1 + (grow * theight) + Math.floor((theight / 2) - (8 / 2)), bgcol)" line786="                    }" line787="                }" line788="            } else {" line789="                outputimg.print(txt, 1+(gcol * twidth) + Math.floor((twidth / 2) - ((txt.length * 6) / 2)), (grow * theight) + Math.floor((theight / 2) - (8 / 2)), bgcol)" line790="            }" line791="        }" line792="        myDate.inProcess[&quot;calendar&quot;] = false" line793="        return outputimg" line794="    }" line795="" line796="    /**" line797="     * Get all values of time as numbers. " line798="     * @param mydt is the datetime object as mydatetime" line799="     */" line800="    //% blockid=datetime_alldatetimetogetinstatement" line801="    //% block=&quot; $mydt date and time as numbers $hour:$minute.$second on $month/$day/$year&quot; advanced=true" line802="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line803="    //% handlerStatement" line804="    //% draggableParameters=&quot;reporter&quot;" line805="    //% group=&quot;param in state&quot;" line806="    //% weight=100" line807="    export function numericTime(mydt: dtobj, handler: (hour: Hour, minute: Minute, second: Second, month: Month, day: Day, year: Year) =&gt; void) {" line808="        const cpuTime4 = cpuTimeInSeconds()" line809="        const w = timeFor(mydt, cpuTime4)" line810="        handler(w.hour, w.minute, w.second, w.month, w.day, w.year)" line811="    }" line812="" line813="    /**" line814="     * Current time as a string in the format" line815="     * @param mydt is the datetime object as mydatetime" line816="     * @param format the format to use" line817="     */" line818="    //% blockid=datetime_time2format" line819="    //% block=&quot; $mydt time as $format&quot;" line820="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line821="    //% group=&quot;text output&quot;" line822="    //% weight=70" line823="    export function time(mydt: dtobj, format: TimeFormat): string {" line824="        const cpuTime5 = cpuTimeInSeconds()" line825="        const a = timeFor(mydt, cpuTime5)" line826="" line827="        // Handle 24-hour format with helper" line828="        if (format == TimeFormat.HHMMSS24hr)" line829="            return fullTime(a)" line830="" line831="        // Format minutes for all remaining formats" line832="        let minute3 = leftZeroPadTo(a.minute, 2)" line833="" line834="        // Simpler military format" line835="        if (format == TimeFormat.HHMM24hr)" line836="            return leftZeroPadTo(a.hour, 2) + &quot;:&quot; + minute3" line837="" line838="        // Data for all other formats" line839="        // Compute strings for other formats" line840="        let hour3 = null" line841="        let ap = a.hour &lt; 12 ? &quot;am&quot; : &quot;pm&quot;" line842="        if (a.hour == 0) {" line843="            hour3 = &quot;12:&quot;  // am" line844="        } else if (a.hour &gt; 12) {" line845="            hour3 = (a.hour - 12) + &quot;:&quot;" line846="        } else {" line847="            hour3 = (a.hour) + &quot;:&quot;" line848="        }" line849="" line850="        // Compose them appropriately" line851="        switch (format) {" line852="            case TimeFormat.HMMSSAMPM:" line853="                return hour3 + minute3 + &quot;.&quot; + leftZeroPadTo(a.second, 2) + ap" line854="" line855="            case TimeFormat.HMMAMPM:" line856="                return hour3 + minute3 + ap" line857="" line858="            case TimeFormat.HMM:" line859="                return hour3 + minute3" line860="        }" line861="        return &quot;&quot;" line862="    }" line863="" line864="    /**" line865="     * Current date month name as a string in the format name" line866="     * @param mydt is the datetime object as mydatetime" line867="     * @param format the format to use" line868="     */" line869="    //% blockid=datetime_datemonth2format " line870="    //% block=&quot; $mydt month name as $format&quot;" line871="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line872="    //% group=&quot;text output&quot;" line873="    //% weight=20" line874="    export function nameMonth(mydt: dtobj, format: MonthNameFormat): string {" line875="        const cpuTime6 = cpuTimeInSeconds()" line876="        const b = timeFor(mydt, cpuTime6)" line877="        const dtIdx = monthName[0].indexOf(b.month.toString())" line878="        const dtName = monthName[1][dtIdx]" line879="        switch (format) {" line880="            case MonthNameFormat.Fname:" line881="                return dtName" line882="                break" line883="            case MonthNameFormat.Sname:" line884="                return dtName.substr(0, 3)" line885="                break" line886="        }" line887="        return &quot;&quot;" line888="    }" line889="" line890="    /**" line891="     * Current date week name as a string in the format name" line892="     * @param mydt is the datetime object as mydatetime" line893="     * @param format the format to use" line894="     */" line895="    //% blockid=datetime_dateweek2format" line896="    //% block=&quot; $mydt week name as $format&quot;" line897="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line898="    //% group=&quot;text output&quot;" line899="    //% weight=20" line900="    export function nameWeek(mydt: dtobj, format: WeekNameFormat): string {" line901="        const cpuTime7 = cpuTimeInSeconds()" line902="        const c = timeFor(mydt, cpuTime7)" line903="        const d = dateToDayOfWeek(datev(c.month, c.day, c.year))" line904="        const dtIdx2 = weekName[0].indexOf(d.toString())" line905="        const dtName2 = weekName[1][dtIdx2]" line906="        switch (format) {" line907="            case WeekNameFormat.Fname:" line908="                return dtName2" line909="                break" line910="            case WeekNameFormat.S3name:" line911="                return dtName2.substr(0, 3)" line912="                break" line913="            case WeekNameFormat.S2name:" line914="                return dtName2.substr(0, 2)" line915="                break" line916="        }" line917="        return &quot;&quot;" line918="    }" line919="" line920="    /**" line921="     * Current date as a string in the format" line922="     * @param mydt is the datetime object as mydatetime" line923="     * @param format the format to use" line924="     * @param ytype the year type to use" line925="     */" line926="    //% blockid=datetime_date2format" line927="    //% block=&quot; $mydt date as $format|| for buddhist year $ytype&quot;" line928="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line929="    //% yf.shadow=toggleYesNo" line930="    //% group=&quot;text output&quot;" line931="    //% weight=60" line932="    export function date(mydt: dtobj, format: DateFormat, yf: boolean = false): string {" line933="        const cpuTime8 = cpuTimeInSeconds()" line934="        const e = timeFor(mydt, cpuTime8)" line935="        const f = dateToDayOfWeek(datev(e.month, e.day, e.year))" line936="        const dtIdx3 = [monthName[0].indexOf(e.month.toString()), weekName[0].indexOf(f.toString())]" line937="        const dtName3 = [monthName[1][dtIdx3[0]], weekName[1][dtIdx3[1]]]" line938="        switch (format) {" line939="            case DateFormat.DWnsMns:" line940="                return e.day + &quot;/&quot; + dtName3[1].substr(0, 3).toUpperCase() + &quot;/&quot; + dtName3[0].substr(0, 3).toUpperCase()" line941="                break" line942="            case DateFormat.DWnMn:" line943="                return e.day + &quot;/&quot; + dtName3[1] + &quot;/&quot; + dtName3[0]" line944="                break" line945="            case DateFormat.MD:" line946="                return e.month + &quot;/&quot; + e.day" line947="                break" line948="            case DateFormat.MDY:" line949="                e.year += (yf)?543:0" line950="                return e.month + &quot;/&quot; + e.day + &quot;/&quot; + e.year" line951="                break" line952="            case DateFormat.YYYY_MM_DD:" line953="                return fullYear(e, yf)" line954="                break" line955="" line956="        }" line957="        return &quot;&quot;" line958="    }" line959="" line960="    /**" line961="     * Current date and time in a timestamp format (YYYY-MM-DD HH:MM.SS).  " line962="     */" line963="    //% blockid=datetime_dateandtime " line964="    //% block=&quot; $mydt date and time stamp|| for buddhist year $yf&quot;" line965="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line966="    //% yf.shadow=toggleYesNo" line967="    //% group=&quot;text output&quot;" line968="    //% weight=50" line969="    export function dateTime(mydt: dtobj, yf: boolean = false): string {" line970="        const cpuTime9 = cpuTimeInSeconds()" line971="        const g = timeFor(mydt , cpuTime9)" line972="        return fullYear(g, yf) + &quot; &quot; + fullTime(g)" line973="    }" line974="" line975="    /**" line976="     * Seconds since start of arcade " line977="     */" line978="    //% blockid=datetime_secondsincereset" line979="    //% block=&quot;seconds since arcade start&quot; advanced=true" line980="    //% group=&quot;runtime&quot;" line981="    //% weight=40" line982="    export function secondsSinceReset(): number {" line983="        return cpuTimeInSeconds()" line984="    }" line985="" line986="" line987="    /**" line988="     * Called when get changed" line989="     * @param mydt the datetime object" line990="     * @param type of value update" line991="     */" line992="    //% blockid=datetime_onchanged" line993="    //% block=&quot; $mydt on $updtype changed do&quot; advanced=true" line994="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line995="    //% handlerStatement" line996="    //% group=&quot;state update&quot;" line997="    //% weight=85" line998="    export function onChanged(mydt: dtobj, updtype: ValueUpdate, thendo: () =&gt; void) {" line999="        switch (updtype) {" line1000="            case 0:" line1001="                if (mydt.lastUpdate.second == mydt.mydatetime.second) break;" line1002="                // New second" line1003="                mydt.lastUpdate.second = mydt.mydatetime.second; thendo()" line1004="            break; case 1:" line1005="                if (mydt.lastUpdate.minute == mydt.mydatetime.minute) break;" line1006="                // New minute" line1007="                mydt.lastUpdate.minute = mydt.mydatetime.minute; thendo()" line1008="            break; case 2:" line1009="                if (mydt.lastUpdate.hour == mydt.mydatetime.hour) break;" line1010="                // New hour" line1011="                mydt.lastUpdate.hour = mydt.mydatetime.hour; thendo()" line1012="            break; case 3:" line1013="                if (mydt.lastUpdate.day == mydt.mydatetime.day) break;" line1014="                // New day" line1015="                mydt.lastUpdate.day = mydt.mydatetime.day; thendo()" line1016="            break; case 4:" line1017="                if (mydt.lastUpdate.month == mydt.mydatetime.month) break;" line1018="                // New month" line1019="                mydt.lastUpdate.month = mydt.mydatetime.month; thendo()" line1020="            break; case 5:" line1021="                if (mydt.lastUpdate.year == mydt.mydatetime.year) break;" line1022="                // New year" line1023="                mydt.lastUpdate.year = mydt.mydatetime.year; thendo()" line1024="            break;" line1025="        }" line1026="    }" line1027="" line1028="    /**" line1029="     * get true when changed" line1030="     * @param mydt the datetime object" line1031="     */" line1032="    //% blockId=datetime_ifchanged" line1033="    //% block=&quot;$mydt $updtype is changed&quot; advanced=true" line1034="    //% mydt.shadow=variables_get mydt.defl=myDateTime" line1035="    //% group=&quot;state update&quot;" line1036="    //% weight=83" line1037="    export function isChanged(mydt: dtobj, updtype: ValueUpdate) {" line1038="        switch (updtype) {" line1039="            case 0:" line1040="                if (mydt.lastUpdate.second == mydt.mydatetime.second) break;" line1041="                // New second" line1042="                mydt.lastUpdate.second = mydt.mydatetime.second; return true" line1043="            case 1:" line1044="                if (mydt.lastUpdate.minute == mydt.mydatetime.minute) break;" line1045="                // New minute" line1046="                mydt.lastUpdate.minute = mydt.mydatetime.minute; return true" line1047="            case 2:" line1048="                if (mydt.lastUpdate.hour == mydt.mydatetime.hour) break;" line1049="                // New hour" line1050="                mydt.lastUpdate.hour = mydt.mydatetime.hour; return true" line1051="            case 3:" line1052="                if (mydt.lastUpdate.day == mydt.mydatetime.day) break;" line1053="                // New day" line1054="                mydt.lastUpdate.day = mydt.mydatetime.day; return true" line1055="            case 4:" line1056="                if (mydt.lastUpdate.month == mydt.mydatetime.month) break;" line1057="                // New month" line1058="                mydt.lastUpdate.month = mydt.mydatetime.month; return true" line1059="            case 5:" line1060="                if (mydt.lastUpdate.year == mydt.mydatetime.year) break;" line1061="                // New year" line1062="                mydt.lastUpdate.year = mydt.mydatetime.year; return true" line1063="        }" line1064="        return false" line1065="    }" line1066="" line1067="    // ***************** mydt was just for debugging / evaluate problems in API" line1068="    // Helpful for debugging / testing" line1069="    // /**" line1070="    //  * Seconds since start of year  " line1071="    //  */" line1072="    // //% block=&quot;seconds since year&quot; advanced=true" line1073="    // export function secondsSinceYear(): number {" line1074="    //     const cpuTime = cpuTimeInSeconds()" line1075="    //     const t = timeFor(cpuTime)" line1076="    //     const deltaTime = cpuTime - cpuTimeAtSetpoint" line1077="    //     let sSinceStartOfYear = timeToSetpoint + deltaTime" line1078="    //     return sSinceStartOfYear" line1079="    // }" line1080="" line1081="    // ********************************************************" line1082="}" numlines="1083"></mutation></block></statement></block></xml>